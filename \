use std::collections::HashMap;

use nom::bytes::complete::*;
use nom::character::complete::*;
use nom::combinator::*;
use nom::multi::*;
use nom::sequence::*;
use nom::IResult;

use crate::identifier::{ Identifier, parse_identifier };
use crate::type_id::{ TypeId, parse_type_id };
use crate::block::{ Block, parse_block };
use crate::unify::*;
use crate::unary_expr::Variable;
use crate::trans::*;

#[derive(Debug, Clone)]
pub struct TraitDefinition {
    pub trait_id: Identifier,
    pub types: Vec<(Identifier, TypeId)>,
}

impl TraitDefinition {
    pub fn get_trait_id_pair(&self) -> (Identifier, TraitDefinition) {
        (self.trait_id, self.clone())
    }
}

pub fn parse_trait_definition(s: &str) -> IResult<&str, TraitDefinition> {
    let (s, (_, _, trait_id, _, _, _, op, _, _)) = 
        tuple((tag("trait"), space1, parse_identifier,
            space0, char('{'), space0,
            many0(tuple((tag("type"), space1, parse_identifier, space0, char('='), space0, parse_type_id, space0, char(';')))),
            space0, char('}')))(s)?;
    let types = match op {
        Some((_, _, id0, _, _, _, ty0, _, many, _, _)) => {
            let mut args = vec![(id0, ty0)];
            for (_, _, _, _, id, _, _, _, ty, _) in many {
                args.push((id, ty));
            }
            args
        }
        None => Vec::new(),
    };
    Ok((s, TraitDefinition { trait_id, types }))
}


#[test]
fn parse_trait_definition() {
    println!("{:?}", parse_trait_definition("trait MyTrait { type Output = i64"));
}
#[test]
fn gentype_func_definition_test() {
    let (_, t) = parse_func_definition("fn func(x: i64) -> i64 { let y = x * x; y + x }").unwrap();
    println!("{:?}", t);
    let mut equs = TypeEquations::new();
    t.gen_type(&mut equs).unwrap();
    println!("{:#?}", equs);
}
